# 编译原理笔记14：自下而上语法分析（2）LR 分析

## LR分析

### LR 分析的特点：

1. 采用最一般的无回溯移进-规约方法；
2. 适用于几乎所有程序设计语言；
3. 能及时发现错误；
4. 分析表复杂，难以手工构造。

LR 分析表和驱动器是 LR 分析的核心。

以下讨论会基于下面的文法进行：

```
E → E-T | T		(1)(2)
T → T*F | F		(3)(4)
F → -F | id		(5)(6)
```

上面的文法也能够说明 LR 的适用范围更广：

- 产生式可以左递归（预测分析不支持）
- 同一个符号（ - ）可以既是一元的也是二元的（算符优先分析不支持）



### LR 分析表

分析表分为两个部分，分别是【动作表（Action）】和【转移表（goto）】。

- 两个表的行首是**分析器状态编号**，其对应着识别活前缀的 DFA 的状态；
- 动作表的列首包含终结符和结束符；
- 转移表的列首是文法中的非终结符，转移表中的数字是状态号。

![image-20200727192809618](C:\Users\marsc\AppData\Roaming\Typora\typora-user-images\image-20200727192809618.png)

- 分析表中：
  - s ： Shift
  - r ： Reduce
  - acc ： Accept
  - 空白 ： 报错
- 转移表中的数字对应行首的状态编号

#### 格局与动作

- 开始格局：（#0， ω#， 移进？）
  - 0： 对应分析表左上角的 0 ，其是识别活前缀的 DFA 的初态，任意语法分析都应该从这里开始；
  - ω：全部的输入序列；
  - 改变格局的动作：一般来说刚开始都是要移进的，除非是一开始就查表查到空白的位置然后出错
- 结束格局：（#0E1， #， 接收）
  - #0E1：# 和 0 是配对的，E 和 1 是配对的。E 后面的 1 是通过查询分析表得到的（0 状态遇到 E ，通过查转移表可知对应的是状态编号 1）；
  - 剩余输入为空，所以只有一个 # ；
  - 接收（acc）：当前栈顶状态编号为 1 ，剩余输入序列中读到 # ，故根据查表可知这个 action[s, 1] 对应着动作表中的 acc ，也就是要执行 acc 这个改变格局的动作了。
  - 把整个文法的符号序列都规约为文法的开始符号 E ，就可以执行接收动作了。
- 出错格局：（#δ， ω'# ， 报错）
  - 根据栈顶的状态号和读写头指向的下一终结符（也就是剩余输入的第一个符号）读到了空白，则会到达出错格局。

##### 改变格局的动作的含义：

1. action[s, a] = si：根据当前栈顶状态 s 和当前读到的终结符 a 去查表的 s 行 a 列，确定改变格局的动作。s 意味着要进行移进（Shift），并在移进后转向到 i 状态（将 i 入栈，压在刚刚移进的符号的上面，与刚刚移进的符号配成一对）；
2. action[s, a] = rj：用第 j 个产生式的左部替换掉栈中的句柄（Reduce）；
3. action[s, a] = acc：接收
4. action[s, a] = 空白：报错

##### 转移表含义：

- goto[s, A] = s' ：指示了非终结符的状态转移。s 表示的是次栈顶的状态，A 表示非终结符。

  当我们刚刚执行一个 action[s, a] = rj 时，栈顶的终结符会被弹出并替换为一个非终结符，此时该终结符位于栈顶，与该非终结符配对的状态需要根据栈顶终结符和次栈顶状态来通过查找 goto 表确定，找到后再将该状态值压入栈顶。

完整的规约动作由 action[s, a] = rj 和 goto[s, A] = s' 两个步骤组成

LR 分析器的工作过程其实可以看作是栈的内容和剩余输入序列所组成的二元组的变化过程（改变格局的动作，也是基于这两个东西去查找分析表确定的），分析开始时的二元组为（#0, a<sub>0</sub>a<sub>1</sub>...a<sub>n</sub>#），中间每一步的结果就可以表示为（#0X<sub>1</sub>s<sub>1</sub>X<sub>2</sub>s<sub>2</sub>...X<sub>m</sub>s<sub>m</sub>, a<sub>i</sub>a<sub>i+1</sub>...a<sub>n</sub>#），栈中的全是文法符号和状态的组合构成的序列。该序列就是一个活前缀，该前缀由 a<sub>0</sub>~a<sub>i-1</sub> 规约而成。

- 移进：当要对 ai 进行移进时，就要先将 ai 入栈，然后根据 sm 和 ai 去查分析表确定下一状态 s，确定后将 s 入栈，读写头指向下一个符号；
- 规约：每次规约后，都要查找 goto 表，生成与栈顶配对的状态编号
  - 若 action[s<sub>m</sub>, a<sub>i</sub>] = 规约A→β，则说明栈顶一段的符号已经形成了 β 文法符号序列，可以进行规约了。
  - 规约需要先将整个 β 出栈（因符号和状态编号配对，故总计需要弹出 2|β| 次。全部弹出完成后暴露出状态 s<sub>m-|β|</sub>），A 入栈。
  - 此时通过次栈顶 s<sub>m-|β|</sub> 和栈顶 A 值查找 goto 表，将结果 goto[ s<sub>m-|β|</sub>, A] = s 入栈。这个 s 就是和 A 配对的状态。

LR 分析算法：

![image-20200728093835016](C:\Users\marsc\AppData\Roaming\Typora\typora-user-images\image-20200728093835016.png)

![image-20200728093811232](C:\Users\marsc\AppData\Roaming\Typora\typora-user-images\image-20200728093811232.png)





若文法 G 的分析表中不含多重定义的条目，则该文法为 LR(k) 文法，对应分析器即 LR(k) 分析器，对应语言即 LR(k) 语言。L：从左到右扫描，R：逆序是最右推导，k：为了确定下一动作会向前扫描的终结符个数——当确定栈顶是某个产生式的右部时，要再向后扫描输入序列k个符号，才能决定是否用该产生式及逆行规约。一般 k<=1 ，k=1 则简称为 LR

这个规约过程中向后扫描终结符，是为了解决【规约-规约冲突】的问题——当规约栈顶可用的产生式的选择超过一个时，可以通过扫描输入序列中后面的一个终结符来辅助判断，决定使用哪个产生式进行规约（这里就要用到这几个右部对应的左部非终结符的 FOLLOW 集合进行判断）



LR分析器是一类分析器。根据分析表的构造，有 LR(0)、SLR(1)、LALR(1)、LR(1) 分析器。这几个分析器的功能和构造难度都依次递增。一般不构造 k>1 的分析器（因为太复杂）



## LR(0) 项目和 LR(0) 项目集规范族

### LR(0) 分析表的构造：

1. 构造一个可以识别文法 G 中所有活前缀的 DFA；
2. 根据 DFA 构造 LR(0) 分析表

#### 活前缀

文法 G 中，若在符号序列 α 右边增添零或多个终结符后，能够形成一个右句型且 α 不含该句型句柄之后的任何符号，则 α 为 G 的活前缀。

- 在推导的过程中，若每次直接推导均替换句型中最右边的非终结符，则称为最右推导。由最右推导产生的句型被称为右句型
- 句柄，是一个句型的最左直接短语
- LR 分析的任何时刻，栈中的序列都是一个活前缀。如果输入的串语法结构正确，则把输入串中的剩余部分匹配到这个活前缀的后面就能够形成一个右句型
- 活前缀其实就是一个符号串，一个文法会有很多的活前缀
- 只要保证已经扫描过的输入序列都可以规约成一个活前缀，则到目前为止的分析就是正确的。

土味：俺寻思啊，这个活前缀，其实就是说【仍然灵活的前缀】。活前缀首先是一个前缀，然后它又是具有灵活性的（能够被塑造、向着不同的方向变化的）

![image-20200728103749352](C:\Users\marsc\AppData\Roaming\Typora\typora-user-images\image-20200728103749352.png)

比如对于这个活前缀 a ，我们可以为它找到一个右句型 aABe，a 是这个句型的前缀，而 aABe 的句柄是 aABe 本身（自己是自己的最左直接短语）， a 显然是构成该句柄的一部分，也就不包含句柄之后的任何符号。（活前缀可以不包含句柄，可以包含句柄的一部分或全部符号）

（把上面这个全都自己解析一遍去。。。）

#### 构造 LR(0) 分析器的关键：为 G 构造一个识别它的所有活前缀的 DFA

步骤：先构造识别活前缀的 NFA，再通过确定化、最小化转为 DFA。

这个 NFA 就是用来识别所有语法 G 的活前缀的，其**从初态到终态路径上的标记就是活前缀**。

##### 状态转换图：

其实就是从产生式直接翻译过来的

![image-20200728111524225](C:\Users\marsc\AppData\Roaming\Typora\typora-user-images\image-20200728111524225.png)

E，就是 E 推导出来的符号序列连接上一个加号再连接上一个 T 推导出来的符号序列

0状态表示状态转换图的初态，在0状态开始，期望看到的是 E+T 推导出来的输入序列

1状态表示已经看到了 E 推导出来的输入序列，期望从1开始看到 +T 推导出来的输入序列。

也就是说，识别活前缀就是要在 NFA 的状态中记录下【我看到了产生式的哪个部分、没有看到哪个部分】，即，识别活前缀的 NFA 状态中应该包含并体现产生式的信息（直接放在状态转移上即可）、已经看到和还没有看到的信息（要在产生式上加一个圆点，通过圆点的位置体现看到的和没看到的。）

NFA 的每个状态都应该能够记录 **从初态到当前状态，已经看到了哪个产生式右部的多少内容。**只有这样才能确定：如果分析器处于当前状态，则下一步该移进还是该规约，以及规约时要用大的产生式。

产生式右部加入的点 . 在右部的位置表示一个 NFA 的状态（这样一个加圆点的产生式就叫做一个【LR(0)项目】），即，用一个 LR(0) 项目表示一个 NFA 状态

一个 LR(0) 项目（简称为**项目**） 是一个产生式，其右部的某个位置有一个点“.”，对于 A → ε 仅有一个项目 A → .

这样的一个项目就代表 NFA 的一个状态，点前面的表示已经看到的，后面的表示没有看到的产生式部分。

![image-20200728112441391](C:\Users\marsc\AppData\Roaming\Typora\typora-user-images\image-20200728112441391.png)

![image-20200728112706894](C:\Users\marsc\AppData\Roaming\Typora\typora-user-images\image-20200728112706894.png)

到达最后的 T\*F. ，就意味着可以用 T → T\*F 进行规约了，规约为 T

后面的学习路线：

![image-20200728112814092](C:\Users\marsc\AppData\Roaming\Typora\typora-user-images\image-20200728112814092.png)

方法：

![image-20200728113148869](C:\Users\marsc\AppData\Roaming\Typora\typora-user-images\image-20200728113148869.png)

![image-20200728113220252](C:\Users\marsc\AppData\Roaming\Typora\typora-user-images\image-20200728113220252.png)

所有的状态都是 NFA 的终态，红圈圈上的是【句柄识别态】，这些时候的圆点都在整个产生式的最右端，语法分析处于这些状态的时候意味着已经【看到了产生式的完整右部】，自然可以进行规约。

所有的状态都是 NFA 的终态，只要能够在 NFA 中任意找到一条路径，那这条路径的序列就是一个活前缀