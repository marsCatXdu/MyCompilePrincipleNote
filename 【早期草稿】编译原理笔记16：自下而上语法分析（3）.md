# 编译原理笔记16：自下而上语法分析（3）

LR 分析器的核心是分析表和驱动器算法。分析表包括一个动作表和一个转移表，该表行首的编号是识别活前缀的 DFA 的状态编号。动作表的列首是文法中的终结符以及输入序列的结束符，GOTO表的列首是非终结符。

LR 分析的驱动器算法，就是从开始格局起，语法分析器总是根据栈顶的状态以及当前剩余输入的第一个终结符去查找分析表，以确定改变格局的动作，执行该动作，修改栈和剩余输入的内容，如此往复。



DFA 是完全由 LR(0) 项目中包含的信息构造出来的，状态及变迁关系就全部来源于项目

1、2 状态都来自于同一个产生式，区别是圆点的位置不同。

空转移表示的是：如果这个输入序列符合语法规则，则这个符号序列应该是 E 推导出来的符号串。E 可以通过 aA 推导也可以使用 bB 推导。

初态是原文法的拓广文法对应的初态。

因为所有状态都是终态（初态也是终态，识别的活前缀是 ε ），这也就意味着从初态出发，到达的任何一个状态都是该 NFA 可以识别的活前缀。

有了 NFA ，就可以同样使用子集法构造 DFA 了。

![image-20200730154822409](C:\Users\marsc\AppData\Roaming\Typora\typora-user-images\image-20200730154822409.png)

因为 DFA 是子集法构造的，所以 DFA 中的每个状态都是原 NFA 的状态集。而又因为 NFA 的每个状态都对应一个项目，所以此处 DFA 中的每个状态就是一个项目集。根据状态中的项目就可以确定该状态是哪些 NFA 状态构成的。这样构造出来的 DFA 的终态是

对原来的 NFA 的初态求 ε 闭包会得到 DFA 的初态。

在 DFA 中的所有状态都是 DFA 的终态。类比原来的子集法构造词法分析 DFA，这里同样，DFA 的终态是包含原 NFA 终态的那些状态，而原来的就全都是终态了。。。

上图中的 8、10、6、7、11、9 也都是【句柄识别态】

这里的 NFA 和原来的 NFA 还是有区别的：原来的 NFA 状态号就只是一个编号而已，而此处的状态编号却是和项目相对应的，而且状态的转移关系也是基于项目建立起来的。那么其实也可以直接从项目构造 DFA



## 由 LR(0) 项目直接构造识别活前缀的 DFA

LR(0) 项目集规范族：（实际上就是我们要构造的识别活前缀的 DFA 的状态的全体，而 DFA 的每个状态都是一个 LR(0) 项目集）构成识别一个文法活前缀的 DFA 的项目集（状态）的全体，称为这个文法的 LR(0) 项目集规范族。这个规范族提供了建立一类 LR(0) 和 SLR 分析器的基础。

如果题目让计算一个LR(0) 项目集规范族，那其实就是要计算识别活前缀的 DFA

我们先给项目做做分类起起名字，后面要用的：

- 圆点在最右端的项目（如 A → α. ，A 不是拓广文法的开始符号）称为”规约项目“，在出现规约项目的状态就可以进行规约动作；
- 文法开始符号 S' 的规约项目称为”接受项目“（在出现接受项目的状态可以接收？？？）；
- 形如 A → α.aβ 的项目称为”移进项目“，a 为终结符。在该状态下，如果下一个输入是终结符 a 则可以进行移进动作；
- 形如 A → α.Bβ 的项目称为”待约项目“，B 为非终结符。”待约项目“的含义是【等待把 B 规约出来】：如果想要用这个产生式进行规约时，后面看到的需要是 B 能推导出来的符号串。如果想按照该产生式进行规约，则需要先把 B 规约出来，看到 B 之后才能进行后面的规约动作；（B 是非终结符，可是输入序列中么的非终结符啊，那怎么才能用这个产生式呢？当然是先把输入序列中由 B 推导出来的符号序列规约成 B 再回来用这个产生式啊）



### 拓广文法 G'

-------这里有问题

这一步非常重要，为了保证任何一个文法最终构造出来的分析表中有唯一的接收状态（acc），都要先进行拓广。

拓广文法： G' = G ∪ { S' → S }

其实就是先引入一个新的非终结符 S' 作为拓广文法的新的开始符号，并引入新的产生式 S' → S，

-----反正第一步要先拓广文法



### 构造 DFA

1. CLOSURE( I )：从项目集 I 不经过任何文法符号到达的项目全体（和词法分析中的 ε-闭包(I) 的含义相同）
2. GO( I, X )：所有从 I 经文法符号 X 能到达（只需要到达就好了，不止一步也可以。因此要先计算直接到达的，再在能够直接到达的基础上求闭包）的项目全体（注：GO 和 smove 的功能不对等，GO 含有闭包计算）